;; https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-15#name-elliptic-curve-vrf-ecvrf
;; based on new TVM opcodes

const int curve_bit_len = 256;
const int challenge_len = 128;

const int cofactor_power = 3;   ;; 2^3
const int p = (1 << 255) - 19;
const int bad_y = 2707385501144840649318225287225658788936804267575313519463743609750303402022;

int ed25519::validate_pkey(int public_key) inline {
    int key = public_key~load_uint(256);
    public_key.end_parse();
    
    int bad = 0;
    bad |= key == 0;
    bad |= key == 1;
    bad |= key == p;
    bad |= key == p - 1;
    bad |= key == p + 1;
    bad |= key == bad_y;
    bad |= key == p - bad_y;
    return ~ bad;
}

int ecvrf::ed25519::encode_to_curve(slice alpha) inline {
    int ctr = 0;
    
    while (1) {
        int h = begin_cell()
            .store_uint("ton.experimental.ratelance.ecvrf"H, 256)
            .store_slice(alpha)
            .store_uint(ctr, 16)
            .store_uint("ecvrf.back"H, 256)
            .end_cell()
            .cell_hash() % p;
        
        
        ctr += 1;
    }
}

() ecvrf::ed25519::verify(slice public_key, slice alpha, slice pi) inline {
    throw_unless(100, ed25519::validate_pkey(public_key.preload_uint(256)));
    
    slice gamma = pi~load_slice(curve_bit_len);
    int c = pi~load_uint(challenge_len);
    int s = pi~load_uint(curve_bit_len);
    
    int h = 
}